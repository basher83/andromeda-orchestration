---
description: 1Password Connect Secret Management Best Practices
globs:
  - "**/onepassword/**/*"
  - "**/*1pass*"
  - "**/*secret*"
  - "**/vault*"
  - "group_vars/**/*vault*"
  - "host_vars/**/*vault*"
  - "**/*credential*"
  - "playbooks/**/*secret*"
  - "roles/**/vars/*vault*"
alwaysApply: false
---

# 1Password Connect Secret Management

## Security Requirements

- **ALWAYS** use `no_log: true` on tasks that interact with 1Password Connect
- **NEVER** log sensitive data - use debug messages for operation status only
- Use direct token parameters instead of environment variables in production
- Store 1Password tokens in Ansible Vault, not plain text

## Collection Usage

```yaml
# Install collection
ansible-galaxy collection install onepassword.connect

# Use in playbooks
collections:
  - onepassword.connect
```

## Authentication Best Practices

```yaml
# group_vars/all.yml (encrypted with ansible-vault)
op_connect_host: "{{ vault_op_connect_host }}"
op_connect_token: "{{ vault_op_connect_token }}"

# In tasks - direct parameter passing
- name: Create database credentials
  onepassword.connect.generic_item:
    hostname: "{{ op_connect_host }}"
    token: "{{ op_connect_token }}"  # Direct parameter
    vault_id: "{{ app_vault_id }}"
    title: "{{ app_name }}-database-creds"
    state: present
    fields:
      - label: "username"
        field_type: string
        value: "{{ db_user }}"
      - label: "password"
        field_type: concealed
        generate_value: on_create
  no_log: true  # CRITICAL: Always use this
  register: db_creds
```

## Module Selection Guidelines

| Module         | Use Case                       | When to Use                     |
| -------------- | ------------------------------ | ------------------------------- |
| `generic_item` | Create/update/delete secrets   | Managing secret lifecycle       |
| `item_info`    | Retrieve complete item details | Getting all fields from an item |
| `field_info`   | Extract specific field values  | Getting single field value      |

## Field Configuration

```yaml
# Password generation with recipes
fields:
  - label: "api_key"
    field_type: concealed
    generate_value: on_create # only generate if doesn't exist
    generator_recipe:
      length: 64
      include_letters: true
      include_digits: true
      include_symbols: false
    section: "Authentication"

# Use appropriate field types
field_types:
  concealed: "Passwords, API keys, secrets"
  string: "Usernames, descriptions"
  email: "Service account emails"
  url: "API endpoints, service URLs"
  otp: "TOTP authentication secrets"
```

## Error Handling for 1Password Operations

```yaml
- name: Handle 1Password operations safely
  block:
    - name: Create secret
      onepassword.connect.generic_item:
        hostname: "{{ op_connect_host }}"
        token: "{{ op_connect_token }}"
        vault_id: "{{ vault_id }}"
        title: "{{ secret_name }}"
        state: present
        fields: "{{ secret_fields }}"
      no_log: true
      register: secret_result

  rescue:
    - name: Handle authentication errors
      fail:
        msg: "1Password authentication failed. Check token and permissions."
      when: "'AccessDeniedError' in ansible_failed_result.msg"

    - name: Handle connection errors
      fail:
        msg: "Cannot reach 1Password Connect server."
      when: "'ConnectionError' in ansible_failed_result.msg"
```

## Variable Organization for Secrets

```yaml
# Use environment-specific vault mapping
vault_mapping:
  development: "{{ dev_vault_id }}"
  staging: "{{ staging_vault_id }}"
  production: "{{ prod_vault_id }}"

# Dynamic vault selection
target_vault: "{{ vault_mapping[environment] }}"

# Group secrets by application/service
app_secrets:
  - name: "database-connection"
    category: "database"
    fields:
      - label: "username"
        field_type: "string"
        value: "{{ db_user }}"
      - label: "password"
        field_type: "concealed"
        generate_value: "on_create"
```

## Testing and Validation

```yaml
# Use check mode for testing
- name: Test secret creation (dry run)
  onepassword.connect.generic_item:
    hostname: "{{ op_connect_host }}"
    token: "{{ op_connect_token }}"
    vault_id: "{{ app_vault_id }}"
    title: "test-secret"
    state: present
  check_mode: true
  no_log: true
  register: check_result

# Validate connectivity
- name: Verify 1Password Connect access
  onepassword.connect.item_info:
    hostname: "{{ op_connect_host }}"
    token: "{{ op_connect_token }}"
    item: "connectivity-test"
    vault: "{{ test_vault_id }}"
  no_log: true
  failed_when: false
  register: connectivity_test
```

## DRY Principles for Secret Management

### Variable Reuse

```yaml
# Define common recipes once
password_recipes:
  strong:
    length: 32
    include_letters: true
    include_digits: true
    include_symbols: true
  api_key:
    length: 64
    include_letters: true
    include_digits: true
    include_symbols: false

# Reuse across multiple secrets
- name: Create multiple secrets with same recipe
  onepassword.connect.generic_item:
    hostname: "{{ op_connect_host }}"
    token: "{{ op_connect_token }}"
    vault_id: "{{ target_vault }}"
    title: "{{ item.name }}"
    state: present
    fields:
      - label: "password"
        field_type: concealed
        generate_value: on_create
        generator_recipe: "{{ password_recipes[item.recipe_type] }}"
  loop: "{{ application_secrets }}"
  no_log: true
```

### Role-Based Secret Management

```yaml
# roles/app_secrets/tasks/main.yml
- name: Create application secrets
  onepassword.connect.generic_item:
    hostname: "{{ op_connect_host }}"
    token: "{{ op_connect_token }}"
    vault_id: "{{ hostvars[inventory_hostname].vault_id }}"
    title: "{{ app_name }}-{{ item.name }}"
    category: "{{ item.category | default('api_credential') }}"
    state: present
    fields: "{{ item.fields }}"
    tags: "{{ item.tags | default([]) + [app_name, environment] }}"
  loop: "{{ app_secrets }}"
  no_log: true
```

## Security Best Practices

### Token Handling

- Store tokens in encrypted Ansible Vault files
- Use `ansible-vault encrypt_string` for individual values
- Never commit plain text tokens to version control
- Rotate tokens regularly following security policies

### Audit and Compliance

```yaml
# Log secret operations without exposing values
- name: Log secret operation
  debug:
    msg: "Created secret '{{ secret_name }}' in vault '{{ vault_id }}'"
  when: secret_result.changed

# Track secret metadata for compliance
- name: Record secret metadata
  lineinfile:
    path: "/var/log/ansible-secrets.log"
    line: "{{ ansible_date_time.iso8601 }} - {{ ansible_user }} - Created {{ secret_name }}"
  delegate_to: localhost
  when: secret_result.changed
```

Remember: Secure secret management is critical for production systems - always follow the principle of least privilege and encrypt sensitive data!
